// This module contains JavaScript functions that are imported by the user Rust code.
// Networking functions are imported from the virtual network module and glued with the user's module.

import { MutableRefObject, RefObject } from "react";

if (!WebAssembly.instantiateStreaming) {
  // Polyfill for Safari
  WebAssembly.instantiateStreaming = async (resp, importObject) => {
    const source = await (await resp).arrayBuffer();
    return await WebAssembly.instantiate(source, importObject);
  };
}

// Initialize virtual network from the wasm module.
// If `mockDns` is false, the virtual network will also run a name server that will respond to user's requests.
// Takes an optional environment that contains functions imported by the Rust code.
export const initializeVirtualNetwork = (
  vnetModule: MutableRefObject<WebAssembly.Instance>,
  setupNetwork: (exports: any) => void,
  userEnv: {}
) => {
  const env = Object.assign(
    {
      notify_rx: (_res_ptr, _len) => {
        // ignore rx for now
      },
      notify_tx: (_res_ptr, _len) => {},
      test_completed: () => {
        // not applicable
      },
      print_log: (ptr, size) => {
        const heap = new Uint8Array(
          (vnetModule.current.exports.memory as WebAssembly.Memory).buffer
        );

        let s = "";
        for (let i = ptr; i < ptr + size; ++i)
          s += String.fromCharCode(heap[i]);

        console.log(s);
      },
    },
    userEnv
  );
  WebAssembly.instantiateStreaming(fetch("/virtualnet.wasm"), { env }).then(
    (module) => {
      vnetModule.current = module.instance;
      setupNetwork(vnetModule.current.exports);
    }
  );
};

export const udp_send_to = (
  vnetModule: RefObject<WebAssembly.Instance>,
  userMod: RefObject<WebAssembly.Instance>
) => (sock, buf, buf_len, dst_ip, dst_port) => {
  const vnetMalloc = vnetModule.current.exports
    .__wbindgen_malloc as CallableFunction;
  const vnetFree = vnetModule.current.exports
    .__wbindgen_free as CallableFunction;

  // allocate memory in the memory of the virtualnet module
  const srcBuf = new Uint8Array(
    (userMod.current.exports.memory as WebAssembly.Memory).buffer
  ).slice(buf, buf + buf_len);

  const vptr = vnetMalloc(buf_len);

  const dstBuf = new Uint8Array(
    (vnetModule.current.exports.memory as WebAssembly.Memory).buffer
  );
  dstBuf.set(srcBuf, vptr);

  (vnetModule.current.exports.udp_send_to as CallableFunction)(
    sock,
    vptr,
    buf_len,
    dst_ip,
    dst_port
  );

  vnetFree(vptr);
};

// TODO: this should be generated by wasm-bindgen
export const udp_recv_from = (
  vnetModule: RefObject<WebAssembly.Instance>,
  userMod: RefObject<WebAssembly.Instance>
) => (sock, buf, buf_len, src_ip_ptr, src_port_ptr) => {
  const vnetMalloc = vnetModule.current.exports
    .__wbindgen_malloc as CallableFunction;
  const vnetFree = vnetModule.current.exports
    .__wbindgen_free as CallableFunction;

  const vptr = vnetMalloc(4 + 2 + buf_len); // src_ip: u32 + src_port: u16 + buf (buf_len)
  const read_size = (vnetModule.current.exports
    .udp_recv_from as CallableFunction)(
    sock,
    vptr + 6,
    buf_len,
    vptr,
    vptr + 4
  );

  if (read_size == 0) {
    // buffer is empty
    vnetFree(vptr);
    return read_size;
  }

  // Read buffers from the virtual net module
  const vnetMemBuf = (vnetModule.current.exports.memory as WebAssembly.Memory)
    .buffer;
  const vnet8 = new Uint8Array(vnetMemBuf);
  const srcIp = vnet8.slice(vptr, vptr + 4);
  const srcPort = vnet8.slice(vptr + 4, vptr + 4 + 2);
  const srcBuffer = vnet8.slice(vptr + 6, vptr + 6 + buf_len);

  // Copy memory to user's module
  const userMemBuf = (userMod.current.exports.memory as WebAssembly.Memory)
    .buffer;
  const user8 = new Uint8Array(userMemBuf);
  user8.set(srcBuffer, buf);
  user8.set(srcIp, src_ip_ptr);
  user8.set(srcPort, src_port_ptr);

  vnetFree(vptr);

  return read_size;
};
